2/25
====

The dragon book!

super computing: cooling!

purple dragon: the most evil dragon

project: 45%   # compiler implementation: C--
midterm 25%
final 25%
quiz: 5%

we have 6 check point for the project

automatic translation & optimization

the traditional view is a narrow view

translation!

silicon compiler: Ex. verilog to VLSI layout

台灣芯悲劇 XD

target machine mode
    pure machine code (ISA)
        assembly language format, relocatable binary format, load-and-go-format
    augmented machine code (ABI)
    bytecode(virtual machine code)

P-code (Pascal)
[wiki](http://en.wikipedia.org/wiki/P-code_machine)

VISA -> virtual ISA


two parts of compilation
    analysis: tokenise, AST, ...
    synthesis: codegen, optimize ...

the difference between interpreter and compiler


interpreter avoids the synthesis part but involves large overhead(time, space)
    portable, dynamic typing
    better diagnostics

hybrid compiler / JIT

a head of time / JIT (adaptive translation) -> profiling


lexical analysis (linear analysis)
syntax analysis (hierarchical analysis)
semantic analysis

codegen
opt



syntax directed compiler

lexical analysis:  error if unrecognized token
syntax analysis: error if can't build ASTs
semantic analysis: type checking! insert type conversion to AST

phases of a compiler

six phases: lexical, syntax, semantic, IR codegen, optimizer, target codegen
symbol table manager / error handler and recovery

optimization: machine dependent optimization / machine independent optimization

setroation elesmatic



3/4
====

review the 6 phases

there's no real registeer in IR, use virtual registeer instead

lexical analyis: FSA (Finite State Automata)
codegen: Tree matching

frondend / backend

common backend compiling system
    variety languages -> IR -> optimizer -> target machine codegen

retargetable compiler
    one language front-end -> IR -> machine independent optimization -> different machine codegen

without IR -> N by M

syntax (structure)
semantics (meaning)

syntax is usually defined by CFG (context free grammar)
semantics: such as type compatibility, scoping rules, context-sensitive

static semantics
    attribute grammars
runtime semantics
    natural semantics
    axiomatic semantics
    denotational semantics

    Ex. assertion

imprecise semantics challenges
    sometimes definitions in the specification of the language are not well defined
    unreachable statements (control may reach end of non-void function)



requirements for a successful languages
many machines failed because they are hard to compile/optimize for
    intel 860    IBM cell    cray-2

codegen
parsing
code optimization
parallelization

instruction parallelism!

cross compilation



ch 2.
design of a simple compiler

type check!

AC program char stream -> lexical analyzer -> token stream -> syntax directed translator -> DC code

AC-to-DC compiler

