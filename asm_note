project with openGL?

fundamentals
data transfers, addressing , arthmetic
procedures
conditional processing
integer arthimetic
advanced procedure
strings / arrays
midterm

hw 15%
project 15%
mid 25%, machine test
final 35%
quiz 10%

no discussing for late penalty for assignments and project

www.cs.nctu.edu.tw/~cswingo/teaching/AssemblyLanguage
EC 706
mail: cswingo@cs.nctu.edu.tw


textbook is important

======================

the difference between C code and assembly language?

like to teach a baby XD

    mov eax, Y
    add eax, 4
    mov ebx, 3
    imul ebx
    mov X, eax

eax, register, like memorization part in your brain

imul => integer (positive)

asm is difficult to maintain, port to other platforms

virtual machine
    language L0, L1
    intepretation
    translation

std::cout << (A*B +C);

mov eax, A
mul B
add eax, C
call WriteInt

=> to intel machine language

specific machine levels:

    high level language
    assembly language
    operating system
    instruction set architecture (ISA)
    microarchitecture
    hardware (digital logic)

data representation
    binary numbers
    storage size
    signed? unsigned?
    character storage

    
hex!

1 for true and 0 for false
MSB most significant bit
LSB least significant bit

MSB    LSB
10110010
7      0

decimal to binary conversion

tow's complement

char representation

boolean algebra
symbolic logic
operators and truth table


flags
    carry, overflow, sign, zero, auxiliary carry, parity
registers
    e for extented
    hi-bit, lo-bit
    eax ... blah
    eip instruction pointer, porgram counter
floating point uni
    mmx, xmm

8 storage for floating numbers
ST(0) ... ST(7)

base:offset

segmented memory

application => OS functions => BIOS => hardware

ASM can be all levels above!

=====================

integer constants
hdbr
hexadecimal, decimal, binary, encoded real
if a value is starting by zero 0A5h => a number, not a variable

quotes like python, double or single is okay

MASM in appendix A

identifier
    not case sensitive

instructions: label, mnemonic, opeand, comment
[label :] mnemonic operands [;comments]

labels
L1:

jump! goto!

operands
    constant, constant expression => immediate values
    register
    memory (data label)



====================

2/22

instruction examples

stc ; set carry flag
inc eax ; regiser
add ebs, ecs
sub myByte, 25
add eax, 36*25

....

INCLUDE Irvine32.inc   ; include the library
.code ; instructions
.data ; data segments

main PROC
    mov eax, 10000h
    mov eax, 40000h
    sub eax, 20000h
    call DumpRegs
    exit
main ENDP
END main              ; <----- very important

keep it simple!


flat 

source code -> assembler -> object file -> linking (with libs)-> excutable
-> OS loader

defining data
intrinsic data types
data definition statement
defining BYTE and SBYTE
WORD, SWORD, DWORD, SDWORD, QWORD, TBYTE
D for double word, Q for quadword 
REAL4, REAL8
Real number
little endian order
http://www.c-jump.com/CIS77/ASM/DataTypes/lecture.html

[name] directive initalizer [, initializer]
values1 BYPE 10

? for don't care value (or uninitialized value)
val BYTE ?, 32, 41h
str1 BYTE "string", 0    ; <---- strings shoud be null-terminated

define all strings used by your program at the same place
(.data)

use the DUP operator : counter DUP(arguments)
Ex.   var BYTE 4 DUP("QQ")   ; "QQQQQQQQ"

SDWORD and DWORD are different!
use 2's comlement

Note: little endian, reverse order byte by byte

declaring uninitialized data

.data?
bigArray DWORD 5000 DUP(?) ; uninitialized data

.data
bigArray DWORD 5000 DUP (?) ; 5000 * 4
decrease the size of the exe files


2/27
===========
if you think something is simple, you still can't learn it during few seconds.


TITLE test_program
INCLUDE Irvine32.inc

.data
.code
main PROC
    call DumpRegs
    exit
main ENDP
END main


set value correctly in the order

$ current location counter
    substract address of list
    difference is the length
list BYTE 10,20,30,40
ListSize = ($ - list)

divide total number of bytes b y 2 (the size of a word)
($ - list) / 2

DWORD => / 4

mov edx, offset String

EQU : like a macro in C, use <...> to to substitution

use BYTE when defining a string (and remember the NUL at the end)

TEXTEQU: text macro

    也可以拿來定義小的 functions


%(...)   ; please compute the actul value of the expression


= use only with immediate values

Register: CF: carry flag, use for check interger overflow

a quiz next week! QAQ


the direct memory operand is a named reference to storage in memory
the named reference is automatically dereferenced buy the assembler
'[var1]' is the the alternate format of 'var' 

3/1
=======
use 'offset' to get the address of a variable
mov al, var1 +4  ; the address of var1, + 4 (bytes), and get the value
the same as mov al, [var1 + 4]

[var1 + a*b]; a-> sizeof type, b-> index
Ex. a = 2 (WORD), 
var1 WORD 01h, 02h
               ^^^index = 1

mov
    can't move from memory to memory
    can't move to CS, EIP, IP
    no immediate to segment moves
    immediate value will be converted to the correct type by the assembler
    immediate value cannot not be destination

movzx -> zero-extension
    add zero in front
movsx -> sign-extension
    convert a negative value to large size
可以小轉大，不能大轉小(廢話XD
    or lose som information

XCHG
    exchange two registers
    no immediate operands are permitted
    notice the operands' size!
    cannot exchange two memory operands, need to mov it to some register

    xchg eax, var2
    xchg eax, var1
    xchg eax, var2

direct offset
    plz use [var + 1] instead of var+1


make sure to initialize register! (like 'ah')
xor bh, bh
notice the little endian representation 


3/6
======
review simple assembly codes

add and sub
    notice with carry flag => 負加負 -> 正www
    overflow, sign, zero, axuiliary carry, parity
    operand use MOV
    remember the 'size', very important

    NEG instruction
        1 -> -1

    Rval = -Xval + (Yval - Zval)

    concept (page 33, state machine)

    most important: ZF, SF, CF, OF

inc, dec => ++ / --
inc and dec no not affect carry flag!

the CPU can not distinguish sign and unsigned

the CPU just compute everything and set the flags!
you should check the flags after every operation

OF / CF
OF: carry out of the MSB XOR carry into the MSB
CF: carry out of the MSB



3/8
=======
overflow (OF)
    two positive operands are added and their sum is negative
    two negative operands are added and their sum is positive

data related operators and directive

OFFSET operator: get the address => becomae typeless


PTR
    type casting
    mov eax, DWOPRD PTR intArray
TYPE -> type of something
LENGTHOF -> number of elements
    ($ - arr) / TYPE arr
SIZEOF -> LENGTHOF * TYPE    in BYTES
    ($ - arr)


indirect addressing
    need two steps

3/13
=======

add a1, 1
inc al      # inc may be more fast

LENGTHOF number of elements
SIZEOF   number of BYTEs

indirect access  []  is typeless!
use type cast like :  inc DWORD PTR [edx]


mov eax, var1      ;; two lines are the same
mov eax, [var1]

;; but in this case, they are different
mov edx, OFFSET var1
mov ebx, [edx]     ;; get the value point by edx
mov ebx, edx       ;; the address of var1

notice the things in [], label or register

indexed operand adds a constant to a register to generate an effective address
[label + reg]

offset in Bytes! notice the type!
mov esi 0
mov ax, [arr + esi]
mov ax arr[esi]

;; 
arr[esi * TYPE arr]

pointer variable

loop lable

    ecx <- ecx - 1
    jmp to lable

count down

carry flag 無論退位還是進位都會亮 (borrow / carry)


3/20
==========
save the loop-counter (ecx)in a variable @nested loop

edi 有 [] 和沒有的差別
    dereference / address

cmp
    the result will set flags

j** : if xxx then jump
comparison
   A and B -> unsigned comparision (above / below)
   G and L -> signed comparision (grate / large)

jump based flags
	 ZF, CF, OF, SF, PF

JCXZ / JECXZ -> jump if CX = 0 / ECX = 0
JE / JNE -> jump equal / not equal
JE and JZ are the same thing

make sure which jmp you need, signed or unsigned?

GotoXY (吃 (dh, dl) (y, x))
WriteChar
SetTextColor (吃 al)

push pop (push to stack)



3/27
==============
save and restore registers when they contain 

sumOf PROC [USES EAX]
    push eax
    add eax, ebx
    add eax, ecx
    pop eax
    ret
sumOf ENDP

如果有寫 USES EAX 的話，可以不寫 push, pop

midterm: mid april

flags

inc, dec will not change CF

AND dst, src
OR dst, src
XOR dst, src

小轉大
and al, 11011111b
大轉小
or al, 0010000b
xor 直接轉


or to set bits 4 and 5   (+= '0')
mov al, 6
or al, 00110000b
'0' == 30h == 00110000h



BIOS segment

mov ax, 40h                         ; BIOS segment
mov ds, ax
mov bx, 17h                         ; keyboard flag byte
or BYTE PTR [bx], 01000000b         ; Capslock on


jmp to label if an integer is even

mov ax, wordVAl
and ax, 1
jnz label


test instruction


jump
jb, ja => unsigned
jg, jl => signed


jb, jc -> CF is set
je, jz -> ZF iss et
js     -> SF is set
jne, jnz -> ZF is clear
jexcz -> ecx = 0

prior to the 386
    jump must within -128 to + 127 from current  location counter
    jumping destination is recorded in only one byte
IA-32
    32-bit offset permits jump anywhere in memory



don't jump too far is you want to write good programs
don't write too large procedures


remember to put a 'b' in binary numbers like 1100b (12 in decimal)

xor 很好用

the syntax is quite strange QQ

loopnz

save flags
    pushfd
    popfd


技巧在於 fall through 跟 Label 順序、使用之 flags

there're multiple correct solutions to this problem

remember the short-circuit behavior when translating pseudo codes 

4/10
========

如果不熟的話，請 practice one hundred times XD

you should answer these questions very quicky

remember AB for unsigned, GL for signed

table driver selection
    call NEAR PTR [ebx + 1]   ; 32 bits
    CaseTable

FSM!!!
finite state machine

sometimes the book may have some mistakes XD


if/else Directive macros

.IF eax > ebx      ; unsigned comparision!
    mov edx, 1
.ELSE
    mov edx, 2
.ENDIF


also we have .WHILE 

我們學習寫程式最大的問題是重現 bug 和 debug
    我有 gdb 我潮強(?


save all registers when use procedures
    注意 registers context!


shift
    ; unsigned, fill zero
    SHL   ; move MSB to CF, fill zero to LSB
    SHR   ; fill zero to MSB, move LSB to CF
	SAL   ; arithmetic shift (keep the MSB), (also move to CF)
    SAR


ROL (rotate left)
    shift each bit to the left
    MSB will be copied into CF and LSB
    no bits are lost

ROR (rotate right)

RCL (rotate carry left)
RCR (rotate carry right)
	連同 CF 一起 rotate

SHLD
    shift a dst operand a given number of bits to the left
    mov ax aaa
    shld val, ax, 4  (shift 4 bit in ax to val)

SHRD
    shld dst, src, count
    shrd dst, src, count


shift multiple DWORD

.data
arrSize = 3
arr DWORD arrSize DUP(99999999h)
.code
mov esi, 0
shr arr[esi + 8], 1   ; high dword
rcr arr[esi + 4], 1   ; middle dword, include carry
rcr arr[esi], 1       ; low dword, include carry





4/12
=========
multiple words shift

shr + rcr + rcr ...

multiply by 26 -> 16 + 8 + 2

this is a very good exercise for you

