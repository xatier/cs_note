project with openGL?

fundamentals
data transfers, addressing , arthmetic
procedures
conditional processing
integer arthimetic
advanced procedure
strings / arrays
midterm

hw 15%
project 15%
mid 25%, machine test
final 35%
quiz 10%

no discussing for late penalty for assignments and project

www.cs.nctu.edu.tw/~cswingo/teaching/AssemblyLanguage
EC 706
mail: cswingo@cs.nctu.edu.tw


textbook is important

======================

the difference between C code and assembly language?

like to teach a baby XD

    mov eax, Y
    add eax, 4
    mov ebx, 3
    imul ebx
    mov X, eax

eax, register, like memorization part in your brain

imul => integer (positive)

asm is difficult to maintain, port to other platforms

virtual machine
    language L0, L1
    intepretation
    translation

std::cout << (A*B +C);

mov eax, A
mul B
add eax, C
call WriteInt

=> to intel machine language

specific machine levels:

    high level language
    assembly language
    operating system
    instruction set architecture (ISA)
    microarchitecture
    hardware (digital logic)

data representation
    binary numbers
    storage size
    signed? unsigned?
    character storage

    
hex!

1 for true and 0 for false
MSB most significant bit
LSB least significant bit

MSB    LSB
10110010
7      0

decimal to binary conversion

tow's complement

char representation

boolean algebra
symbolic logic
operators and truth table


flags
    carry, overflow, sign, zero, auxiliary carry, parity
registers
    e for extented
    hi-bit, lo-bit
    eax ... blah
    eip instruction pointer, porgram counter
floating point uni
    mmx, xmm

8 storage for floating numbers
ST(0) ... ST(7)

base:offset

segmented memory

application => OS functions => BIOS => hardware

ASM can be all levels above!

=====================

integer constants
hdbr
hexadecimal, decimal, binary, encoded real
if a value is starting by zero 0A5h => a number, not a variable

quotes like python, double or single is okay

MASM in appendix A

identifier
    not case sensitive

instructions: label, mnemonic, opeand, comment
[label :] mnemonic operands [;comments]

labels
L1:

jump! goto!

operands
    constant, constant expression => immediate values
    register
    memory (data label)



====================

2/22

instruction examples

stc ; set carry flag
inc eax ; regiser
add ebs, ecs
sub myByte, 25
add eax, 36*25

....

INCLUDE Irvine32.inc   ; include the library
.code ; instructions
.data ; data segments

main PROC
    mov eax, 10000h
    mov eax, 40000h
    sub eax, 20000h
    call DumpRegs
    exit
main ENDP
END main              ; <----- very important

keep it simple!


flat 

source code -> assembler -> object file -> linking (with libs)-> excutable
-> OS loader

defining data
intrinsic data types
data definition statement
defining BYTE and SBYTE
WORD, SWORD, DWORD, SDWORD, QWORD, TBYTE
D for double word, Q for quadword 
REAL4, REAL8
Real number
little endian order
http://www.c-jump.com/CIS77/ASM/DataTypes/lecture.html

[name] directive initalizer [, initializer]
values1 BYPE 10

? for don't care value (or uninitialized value)
val BYTE ?, 32, 41h
str1 BYTE "string", 0    ; <---- strings shoud be null-terminated

define all strings used by your program at the same place
(.data)

use the DUP operator : counter DUP(arguments)
Ex.   var BYTE 4 DUP("QQ")   ; "QQQQQQQQ"

SDWORD and DWORD are different!
use 2's comlement

Note: little endian, reverse order byte by byte

declaring uninitialized data

.data?
bigArray DWORD 5000 DUP(?) ; uninitialized data

.data
bigArray DWORD 5000 DUP (?) ; 5000 * 4
decrease the size of the exe files


2/27
===========
if you think something is simple, you still can't learn it during few seconds.


TITLE test_program
INCLUDE Irvine32.inc

.data
.code
main PROC
    call DumpRegs
    exit
main ENDP
END main


set value correctly in the order

$ current location counter
    substract address of list
    difference is the length
list BYTE 10,20,30,40
ListSize = ($ - list)

divide total number of bytes b y 2 (the size of a word)
($ - list) / 2

DWORD => / 4

mov edx, offset String

EQU : like a macro in C, use <...> to to substitution

use BYTE when defining a string (and remember the NUL at the end)

TEXTEQU: text macro

    也可以拿來定義小的 functions


%(...)   ; please compute the actul value of the expression


= use only with immediate values

Register: CF: carry flag, use for check interger overflow

a quiz next week! QAQ


the direct memory operand is a named reference to storage in memory
the named reference is automatically dereferenced buy the assembler
'[var1]' is the the alternate format of 'var' 

3/1
=======
use 'offset' to get the address of a variable
mov al, var1 +4  ; the address of var1, + 4 (bytes), and get the value
the same as mov al, [var1 + 4]

[var1 + a*b]; a-> sizeof type, b-> index
Ex. a = 2 (WORD), 
var1 WORD 01h, 02h
               ^^^index = 1

mov
    can't move from memory to memory
    can't move to CS, EIP, IP
    no immediate to segment moves
    immediate value will be converted to the correct type by the assembler
    immediate value cannot not be destination

movzx -> zero-extension
    add zero in front
movsx -> sign-extension
    convert a negative value to large size
可以小轉大，不能大轉小(廢話XD
    or lose som information

XCHG
    exchange two registers
    no immediate operands are permitted
    notice the operands' size!
    cannot exchange two memory operands, need to mov it to some register

    xchg eax, var2
    xchg eax, var1
    xchg eax, var2

direct offset
    plz use [var + 1] instead of var+1


make sure to initialize register! (like 'ah')
xor bh, bh
notice the little endian representation 


3/6
======
review simple assembly codes

add and sub
    notice with carry flag => 負加負 -> 正www
    overflow, sign, zero, axuiliary carry, parity
    operand use MOV
    remember the 'size', very important

    NEG instruction
        1 -> -1

    Rval = -Xval + (Yval - Zval)

    concept (page 33, state machine)

    most important: ZF, SF, CF, OF

inc, dec => ++ / --
inc and dec no not affect carry flag!

the CPU can not distinguish sign and unsigned

the CPU just compute everything and set the flags!
you should check the flags after every operation

OF / CF
OF: carry out of the MSB XOR carry into the MSB
CF: carry out of the MSB



3/8
=======
overflow (OF)
    two positive operands are added and their sum is negative
    two negative operands are added and their sum is positive

data related operators and directive

OFFSET operator: get the address => becomae typeless


PTR
    type casting
    mov eax, DWOPRD PTR intArray
TYPE -> type of something
LENGTHOF -> number of elements
    ($ - arr) / TYPE arr
SIZEOF -> LENGTHOF * TYPE    in BYTES
    ($ - arr)


indirect addressing
    need two steps
